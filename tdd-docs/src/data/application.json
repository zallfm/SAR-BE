{
  "name": "application",
  "displayName": "Application",
  "description": "Application master data management",
  "functions": [
    {
      "name": "normalizeStatus",
      "signature": "normalizeStatus(input: any): \"Active\" | \"Inactive\" | undefined",
      "description": "Normalize application status from various input formats to standard Active/Inactive",
      "category": "service",
      "testScenarios": [
        {
          "id": "app-normalize-001",
          "name": "Normalize String Status",
          "phase": "RED",
          "description": "Should normalize string status to Active/Inactive",
          "testCode": "it('should normalize status strings', () => {\n  expect(applicationService.normalizeStatus({ APPLICATION_STATUS: 'active' })).toBe('Active');\n  expect(applicationService.normalizeStatus({ APPLICATION_STATUS: 'inactive' })).toBe('Inactive');\n  expect(applicationService.normalizeStatus({ status: 'aktif' })).toBe('Active');\n});"
        }
      ],
      "todos": [
        {
          "id": "todo-normalizeStatus-001",
          "task": "Setup test file: src/tests/unit/application.service.spec.ts",
          "status": "pending",
          "priority": "high",
          "description": "Create test file with describe block for applicationService.normalizeStatus"
        },
        {
          "id": "todo-normalizeStatus-002",
          "task": "Write test: Normalize from APPLICATION_STATUS field",
          "status": "pending",
          "priority": "high",
          "description": "Test normalization from APPLICATION_STATUS property"
        },
        {
          "id": "todo-normalizeStatus-003",
          "task": "Write test: Normalize from status field (lowercase)",
          "status": "pending",
          "priority": "high",
          "description": "Test normalization from status property"
        },
        {
          "id": "todo-normalizeStatus-004",
          "task": "Write test: Normalize from appStatus field",
          "status": "pending",
          "priority": "medium",
          "description": "Test normalization from appStatus property"
        },
        {
          "id": "todo-normalizeStatus-005",
          "task": "Write test: Normalize boolean values",
          "status": "pending",
          "priority": "medium",
          "description": "Test boolean true -> Active, false -> Inactive"
        },
        {
          "id": "todo-normalizeStatus-006",
          "task": "Write test: Handle Indonesian language (aktif/inaktif)",
          "status": "pending",
          "priority": "medium",
          "description": "Test normalization for Indonesian status values"
        },
        {
          "id": "todo-normalizeStatus-007",
          "task": "Write test: Handle single character codes (a/0 -> Active, i/1 -> Inactive)",
          "status": "pending",
          "priority": "low",
          "description": "Test normalization for short codes"
        },
        {
          "id": "todo-normalizeStatus-008",
          "task": "Write test: Return undefined for invalid values",
          "status": "pending",
          "priority": "medium",
          "description": "Test that invalid or unrecognized values return undefined"
        },
        {
          "id": "todo-normalizeStatus-009",
          "task": "Implement normalizeStatus function",
          "status": "pending",
          "priority": "high",
          "description": "Implement function to normalize status from various input formats"
        }
      ],
      "bddScenarios": [
        {
          "id": "bdd-normalizeStatus-001",
          "name": "Feature: Normalize Application Status",
          "description": "As a developer, I want to normalize application status from various input formats so that I can handle different frontend formats consistently",
          "scenarios": [
            {
              "id": "bdd-normalizeStatus-001-001",
              "name": "Scenario: Normalize Status from APPLICATION_STATUS Field",
              "given": [
                "Input object has APPLICATION_STATUS property",
                "APPLICATION_STATUS value is 'active' (case-insensitive)"
              ],
              "when": [
                "normalizeStatus is called with the input object"
              ],
              "then": [
                "System returns 'Active'",
                "System handles case-insensitive matching"
              ],
              "testCode": "it('should normalize from APPLICATION_STATUS field', () => {\n  expect(applicationService.normalizeStatus({ APPLICATION_STATUS: 'active' })).toBe('Active');\n  expect(applicationService.normalizeStatus({ APPLICATION_STATUS: 'ACTIVE' })).toBe('Active');\n  expect(applicationService.normalizeStatus({ APPLICATION_STATUS: 'inactive' })).toBe('Inactive');\n});"
            },
            {
              "id": "bdd-normalizeStatus-001-002",
              "name": "Scenario: Normalize Status from Boolean Value",
              "given": [
                "Input has boolean status value",
                "Boolean value is true or false"
              ],
              "when": [
                "normalizeStatus is called with boolean value"
              ],
              "then": [
                "System returns 'Active' for true",
                "System returns 'Inactive' for false"
              ],
              "testCode": "it('should normalize boolean values', () => {\n  expect(applicationService.normalizeStatus({ APPLICATION_STATUS: true })).toBe('Active');\n  expect(applicationService.normalizeStatus({ APPLICATION_STATUS: false })).toBe('Inactive');\n});"
            },
            {
              "id": "bdd-normalizeStatus-001-003",
              "name": "Scenario: Normalize Status from Indonesian Language",
              "given": [
                "Input has Indonesian status value",
                "Status value is 'aktif' or 'inaktif'"
              ],
              "when": [
                "normalizeStatus is called with Indonesian value"
              ],
              "then": [
                "System returns 'Active' for 'aktif'",
                "System returns 'Inactive' for 'inaktif'"
              ],
              "testCode": "it('should normalize Indonesian status', () => {\n  expect(applicationService.normalizeStatus({ status: 'aktif' })).toBe('Active');\n  expect(applicationService.normalizeStatus({ status: 'inaktif' })).toBe('Inactive');\n});"
            }
          ]
        }
      ]
    },
    {
      "name": "create",
      "signature": "async create(input: ApplicationCreateDTO, auditUser: string): Promise<Application>",
      "description": "Create new application with validation",
      "category": "service",
      "testScenarios": [
        {
          "id": "app-create-001",
          "name": "Happy Path - Create Application",
          "phase": "RED",
          "description": "Should create application when all validations pass",
          "testCode": "it('should create application successfully', async () => {\n  const input = { APPLICATION_ID: 'APP001', APPLICATION_NAME: 'Test App', ... };\n  jest.spyOn(repo, 'findByCode').mockResolvedValue(null);\n  jest.spyOn(repo, 'getUserByNoreg').mockResolvedValue({ NOREG: '123456' });\n  const result = await applicationService.create(input, 'admin');\n  expect(result).toBeDefined();\n});"
        },
        {
          "id": "app-create-002",
          "name": "Error - Duplicate APPLICATION_ID",
          "phase": "RED",
          "description": "Should throw error when APPLICATION_ID already exists",
          "testCode": "it('should throw error for duplicate APPLICATION_ID', async () => {\n  jest.spyOn(repo, 'findByCode').mockResolvedValue({ APPLICATION_ID: 'APP001' });\n  await expect(applicationService.create(input, 'admin')).rejects.toThrow(ApplicationError);\n});"
        }
      ],
      "todos": [
        {
          "id": "todo-create-001",
          "task": "Setup test file: src/tests/unit/application.service.spec.ts (create section)",
          "status": "pending",
          "priority": "high",
          "description": "Add describe block for applicationService.create tests"
        },
        {
          "id": "todo-create-002",
          "task": "Write test: Happy Path - Create Application",
          "status": "pending",
          "priority": "high",
          "description": "Write test case for successful application creation"
        },
        {
          "id": "todo-create-003",
          "task": "Mock repository.findByCode to check duplicates",
          "status": "pending",
          "priority": "high",
          "description": "Mock repository.findByCode to return null (no duplicate)"
        },
        {
          "id": "todo-create-004",
          "task": "Mock repository.getUserByNoreg for validation",
          "status": "pending",
          "priority": "high",
          "description": "Mock repository.getUserByNoreg to validate user exists"
        },
        {
          "id": "todo-create-005",
          "task": "Normalize APPLICATION_STATUS using normalizeStatus",
          "status": "pending",
          "priority": "high",
          "description": "Use normalizeStatus helper to normalize status input"
        },
        {
          "id": "todo-create-006",
          "task": "Implement create function",
          "status": "pending",
          "priority": "high",
          "description": "Implement create function with validation and repository call"
        },
        {
          "id": "todo-create-007",
          "task": "Write test: Duplicate APPLICATION_ID Error",
          "status": "pending",
          "priority": "high",
          "description": "Write test case that expects ApplicationError for duplicate ID"
        },
        {
          "id": "todo-create-008",
          "task": "Add duplicate check validation",
          "status": "pending",
          "priority": "high",
          "description": "Check if APPLICATION_ID already exists before creating"
        },
        {
          "id": "todo-create-009",
          "task": "Write test: Invalid NOREG_SYSTEM_OWNER",
          "status": "pending",
          "priority": "medium",
          "description": "Write test case when user with NOREG_SYSTEM_OWNER not found"
        },
        {
          "id": "todo-create-010",
          "task": "Add NOREG validation",
          "status": "pending",
          "priority": "medium",
          "description": "Validate that NOREG_SYSTEM_OWNER exists in user database"
        },
        {
          "id": "todo-create-011",
          "task": "Add audit fields (CREATED_BY, CREATED_DATE)",
          "status": "pending",
          "priority": "medium",
          "description": "Set CREATED_BY from auditUser and CREATED_DATE to current timestamp"
        },
        {
          "id": "todo-create-012",
          "task": "Call repository.create",
          "status": "pending",
          "priority": "high",
          "description": "Call repository.create with validated and normalized input"
        },
        {
          "id": "todo-create-013",
          "task": "Add publishMonitoringLog for creation",
          "status": "pending",
          "priority": "low",
          "description": "Publish monitoring log for application creation event"
        }
      ],
      "bddScenarios": [
        {
          "id": "bdd-create-001",
          "name": "Feature: Create Application",
          "description": "As a system administrator, I want to create a new application so that it can be managed in the system",
          "scenarios": [
            {
              "id": "bdd-create-001-001",
              "name": "Scenario: Create Application Successfully",
              "given": [
                "APPLICATION_ID 'APP001' does not exist in database",
                "User with NOREG_SYSTEM_OWNER exists",
                "All required fields are provided (APPLICATION_ID, APPLICATION_NAME, DIVISION_ID_OWNER, etc.)",
                "APPLICATION_STATUS is provided (Active or Inactive)"
              ],
              "when": [
                "Administrator calls create with valid application data",
                "System validates APPLICATION_ID uniqueness",
                "System validates NOREG_SYSTEM_OWNER exists",
                "System normalizes APPLICATION_STATUS"
              ],
              "then": [
                "System creates new application in database",
                "System sets CREATED_BY to auditUser",
                "System sets CREATED_DATE to current timestamp",
                "System returns created application object",
                "System normalizes status to 'Active' or 'Inactive'"
              ],
              "testCode": "it('should create application successfully', async () => {\n  // Given\n  const input = {\n    APPLICATION_ID: 'APP001',\n    APPLICATION_NAME: 'Test Application',\n    DIVISION_ID_OWNER: '1',\n    NOREG_SYSTEM_OWNER: '123456',\n    APPLICATION_STATUS: 'active'\n  };\n  jest.spyOn(repo, 'findByCode').mockResolvedValue(null);\n  jest.spyOn(repo, 'getUserByNoreg').mockResolvedValue({ NOREG: '123456' });\n  jest.spyOn(repo, 'create').mockResolvedValue({ ...input, APPLICATION_STATUS: 'Active' });\n  \n  // When\n  const result = await applicationService.create(input, 'admin');\n  \n  // Then\n  expect(result).toBeDefined();\n  expect(result.APPLICATION_ID).toBe('APP001');\n  expect(result.APPLICATION_STATUS).toBe('Active');\n});"
            },
            {
              "id": "bdd-create-001-002",
              "name": "Scenario: Create Application Fails Due to Duplicate ID",
              "given": [
                "APPLICATION_ID 'APP001' already exists in database",
                "Administrator attempts to create application with same ID"
              ],
              "when": [
                "Administrator calls create with duplicate APPLICATION_ID",
                "System checks for existing APPLICATION_ID"
              ],
              "then": [
                "System throws ApplicationError with duplicate error code",
                "System returns appropriate HTTP status code (400 or 409)",
                "System includes error message indicating duplicate ID",
                "Application is not created in database"
              ],
              "testCode": "it('should throw error for duplicate APPLICATION_ID', async () => {\n  // Given\n  const input = { APPLICATION_ID: 'APP001', ... };\n  jest.spyOn(repo, 'findByCode').mockResolvedValue({ APPLICATION_ID: 'APP001' });\n  \n  // When & Then\n  await expect(applicationService.create(input, 'admin')).rejects.toThrow(ApplicationError);\n  \n  try {\n    await applicationService.create(input, 'admin');\n  } catch (error) {\n    expect(error.code).toBe(ERROR_CODES.APP_DUPLICATE_ID);\n  }\n});"
            }
          ]
        }
      ]
    },
    {
      "name": "list",
      "signature": "async list(params: ListParams): Promise<PaginatedResponse<Application>>",
      "description": "Get paginated list of applications",
      "category": "service",
      "testScenarios": [
        {
          "id": "app-list-001",
          "name": "Happy Path - List Applications",
          "phase": "RED",
          "description": "Should return paginated list of applications",
          "testCode": "it('should return paginated applications', async () => {\n  const params = { page: 1, limit: 10, sortField: 'CREATED_DT', sortOrder: 'asc' };\n  jest.spyOn(repo, 'list').mockResolvedValue({ data: [], total: 0 });\n  const result = await applicationService.list(params);\n  expect(result.data).toBeDefined();\n});"
        }
      ],
      "todos": [
        {"id": "todo-list-001", "task": "Setup test file: src/tests/unit/application.service.spec.ts (list section)", "status": "pending", "priority": "high", "description": "Add describe block for applicationService.list tests"},
        {"id": "todo-list-002", "task": "Write test: Happy Path - List Applications", "status": "pending", "priority": "high", "description": "Write test case for successful paginated list"},
        {"id": "todo-list-003", "task": "Mock repository.list", "status": "pending", "priority": "high", "description": "Mock repository.list to return paginated data"},
        {"id": "todo-list-004", "task": "Implement list function", "status": "pending", "priority": "high", "description": "Call repository.list with params and return result"},
        {"id": "todo-list-005", "task": "Write test: Search functionality", "status": "pending", "priority": "medium", "description": "Write test for search by APPLICATION_ID or APPLICATION_NAME"},
        {"id": "todo-list-006", "task": "Write test: Sorting functionality", "status": "pending", "priority": "medium", "description": "Test sorting by sortField and sortOrder"},
        {"id": "todo-list-007", "task": "Write test: Pagination", "status": "pending", "priority": "medium", "description": "Test pagination with page and limit parameters"}
      ],
      "bddScenarios": [
        {
          "id": "bdd-list-001",
          "name": "Feature: List Applications",
          "description": "As a user, I want to retrieve a paginated list of applications so that I can browse and find applications",
          "scenarios": [
            {
              "id": "bdd-list-001-001",
              "name": "Scenario: List Applications with Pagination",
              "given": ["Applications exist in database", "User requests paginated list"],
              "when": ["User calls list with page=1, limit=10", "System queries repository"],
              "then": ["System returns paginated response with data array", "System returns total count", "System includes pagination metadata"],
              "testCode": "it('should return paginated applications', async () => {\n  const params = { page: 1, limit: 10, sortField: 'CREATED_DT', sortOrder: 'asc' };\n  jest.spyOn(repo, 'list').mockResolvedValue({ data: [], total: 0 });\n  const result = await applicationService.list(params);\n  expect(result.data).toBeDefined();\n  expect(result.total).toBeDefined();\n});"
            }
          ]
        }
      ]
    },
    {
      "name": "getById",
      "signature": "async getById(id: string): Promise<Application>",
      "description": "Get application by ID",
      "category": "service",
      "testScenarios": [
        {
          "id": "app-getById-001",
          "name": "Happy Path - Application Found",
          "phase": "RED",
          "description": "Should return application when found",
          "testCode": "it('should return application by id', async () => {\n  jest.spyOn(repo, 'findById').mockResolvedValue({ APPLICATION_ID: 'APP001', ... });\n  const result = await applicationService.getById('APP001');\n  expect(result.APPLICATION_ID).toBe('APP001');\n});"
        },
        {
          "id": "app-getById-002",
          "name": "Error - Application Not Found",
          "phase": "RED",
          "description": "Should throw error when application not found",
          "testCode": "it('should throw error when not found', async () => {\n  jest.spyOn(repo, 'findById').mockResolvedValue(null);\n  await expect(applicationService.getById('INVALID')).rejects.toThrow(ApplicationError);\n});"
        }
      ],
      "todos": [
        {"id": "todo-getById-001", "task": "Setup test file: src/tests/unit/application.service.spec.ts (getById section)", "status": "pending", "priority": "high", "description": "Add describe block for applicationService.getById tests"},
        {"id": "todo-getById-002", "task": "Write test: Happy Path - Application Found", "status": "pending", "priority": "high", "description": "Write test case for successful retrieval"},
        {"id": "todo-getById-003", "task": "Mock repository.findById", "status": "pending", "priority": "high", "description": "Mock repository.findById to return application"},
        {"id": "todo-getById-004", "task": "Implement getById function", "status": "pending", "priority": "high", "description": "Call repository.findById and return result"},
        {"id": "todo-getById-005", "task": "Write test: Application Not Found Error", "status": "pending", "priority": "high", "description": "Write test case that expects ApplicationError when not found"},
        {"id": "todo-getById-006", "task": "Add error handling for not found", "status": "pending", "priority": "high", "description": "Throw ApplicationError with APP_NOT_FOUND code when application not found"}
      ],
      "bddScenarios": [
        {
          "id": "bdd-getById-001",
          "name": "Feature: Get Application by ID",
          "description": "As a user, I want to retrieve a specific application by ID so that I can view its details",
          "scenarios": [
            {
              "id": "bdd-getById-001-001",
              "name": "Scenario: Application Found Successfully",
              "given": ["Application with ID 'APP001' exists in database"],
              "when": ["User calls getById with 'APP001'", "System queries repository"],
              "then": ["System returns application object", "Application object contains APPLICATION_ID 'APP001'", "All application fields are populated"],
              "testCode": "it('should return application by id', async () => {\n  jest.spyOn(repo, 'findById').mockResolvedValue({ APPLICATION_ID: 'APP001', APPLICATION_NAME: 'Test App' });\n  const result = await applicationService.getById('APP001');\n  expect(result.APPLICATION_ID).toBe('APP001');\n});"
            },
            {
              "id": "bdd-getById-001-002",
              "name": "Scenario: Application Not Found",
              "given": ["Application with ID 'INVALID' does not exist"],
              "when": ["User calls getById with 'INVALID'", "System queries repository"],
              "then": ["System throws ApplicationError", "Error code is APP_NOT_FOUND", "HTTP status code is 404"],
              "testCode": "it('should throw error when not found', async () => {\n  jest.spyOn(repo, 'findById').mockResolvedValue(null);\n  await expect(applicationService.getById('INVALID')).rejects.toThrow(ApplicationError);\n});"
            }
          ]
        }
      ]
    },
    {
      "name": "update",
      "signature": "async update(id: string, updates: Partial<ApplicationUpdateDTO>, auditUser: string): Promise<Application>",
      "description": "Update application",
      "category": "service",
      "testScenarios": [
        {
          "id": "app-update-001",
          "name": "Happy Path - Update Application",
          "phase": "RED",
          "description": "Should update application successfully",
          "testCode": "it('should update application', async () => {\n  jest.spyOn(repo, 'findById').mockResolvedValue({ APPLICATION_ID: 'APP001' });\n  jest.spyOn(repo, 'update').mockResolvedValue({ ... });\n  const result = await applicationService.update('APP001', { APPLICATION_NAME: 'Updated' }, 'admin');\n  expect(result).toBeDefined();\n});"
        }
      ],
      "todos": [
        {"id": "todo-update-001", "task": "Setup test file: src/tests/unit/application.service.spec.ts (update section)", "status": "pending", "priority": "high", "description": "Add describe block for applicationService.update tests"},
        {"id": "todo-update-002", "task": "Write test: Happy Path - Update Application", "status": "pending", "priority": "high", "description": "Write test case for successful update"},
        {"id": "todo-update-003", "task": "Mock repository.findById to verify existence", "status": "pending", "priority": "high", "description": "Mock repository.findById to return existing application"},
        {"id": "todo-update-004", "task": "Normalize APPLICATION_STATUS if provided", "status": "pending", "priority": "medium", "description": "Use normalizeStatus if APPLICATION_STATUS is in updates"},
        {"id": "todo-update-005", "task": "Implement update function", "status": "pending", "priority": "high", "description": "Check existence, normalize status, call repository.update"},
        {"id": "todo-update-006", "task": "Add audit fields (CHANGED_BY, CHANGED_DATE)", "status": "pending", "priority": "medium", "description": "Set CHANGED_BY from auditUser and CHANGED_DATE to current timestamp"},
        {"id": "todo-update-007", "task": "Write test: Application Not Found Error", "status": "pending", "priority": "high", "description": "Write test case when application does not exist"},
        {"id": "todo-update-008", "task": "Add error handling for not found", "status": "pending", "priority": "high", "description": "Throw ApplicationError when application not found before update"}
      ],
      "bddScenarios": [
        {
          "id": "bdd-update-001",
          "name": "Feature: Update Application",
          "description": "As a system administrator, I want to update an existing application so that I can modify its information",
          "scenarios": [
            {
              "id": "bdd-update-001-001",
              "name": "Scenario: Update Application Successfully",
              "given": ["Application with ID 'APP001' exists", "Updates contain valid fields"],
              "when": ["Administrator calls update with ID and updates", "System validates application exists", "System normalizes status if provided"],
              "then": ["System updates application in database", "System sets CHANGED_BY and CHANGED_DATE", "System returns updated application"],
              "testCode": "it('should update application', async () => {\n  jest.spyOn(repo, 'findById').mockResolvedValue({ APPLICATION_ID: 'APP001' });\n  jest.spyOn(repo, 'update').mockResolvedValue({ APPLICATION_ID: 'APP001', APPLICATION_NAME: 'Updated' });\n  const result = await applicationService.update('APP001', { APPLICATION_NAME: 'Updated' }, 'admin');\n  expect(result).toBeDefined();\n});"
            }
          ]
        }
      ]
    }
  ]
}

