{
  "name": "auth",
  "displayName": "Authentication",
  "description": "User authentication and authorization",
  "functions": [
    {
      "name": "login",
      "description": "Authenticate user with username and password. Includes account lockout mechanism after failed attempts.",
      "signature": "POST /login",
      "method": "POST",
      "endpoint": "/login",
      "testScenarios": [
        {
          "id": "auth-login-001",
          "name": "Happy Path - Valid Credentials",
          "phase": "RED",
          "description": "Should return token and user data when credentials are valid",
          "given": {
            "setup": "User exists in database with valid credentials",
            "code": "const mockUser = { username: 'testuser', password: 'hashedPassword', name: 'Test User', role: 'ADMIN' }; jest.mock('./user.repository', () => ({ userRepository: { login: jest.fn().mockResolvedValue(mockUser) } }));"
          },
          "when": {
            "action": "Call authService.login with valid credentials",
            "code": "const result = await authService.login(app, 'testuser', 'password123', 'req-1');"
          },
          "then": {
            "expectedReturn": "Object with token, expiresIn, and user properties",
            "expectedSideEffects": [
              "AuditLogger.logSuccess called",
              "publishMonitoringLog called with LOGIN_SUCCESS"
            ],
            "code": "expect(result).toHaveProperty('token');\nexpect(result).toHaveProperty('expiresIn');\nexpect(result.user.username).toBe('testuser');\nexpect(result.user.name).toBe('Test User');"
          },
          "testCode": "it('should return token and user when credentials are valid', async () => {\n  const app = await buildApp();\n  const mockUser = { username: 'testuser', password: 'hashedPassword', name: 'Test User', role: 'ADMIN' };\n  \n  jest.spyOn(userRepository, 'login').mockResolvedValue(mockUser);\n  jest.spyOn(require('../../utils/crypto'), 'safeCompare').mockReturnValue(true);\n  \n  const result = await authService.login(app, 'testuser', 'password123', 'req-1');\n  \n  expect(result).toHaveProperty('token');\n  expect(result).toHaveProperty('expiresIn');\n  expect(result.user.username).toBe('testuser');\n  expect(result.user.name).toBe('Test User');\n});",
          "implementationNotes": "Ensure userRepository.login is mocked and safeCompare returns true for valid password"
        },
        {
          "id": "auth-login-002",
          "name": "Error Case - Invalid Credentials",
          "phase": "RED",
          "description": "Should throw ApplicationError with AUTH_INVALID_CREDENTIALS when password is incorrect",
          "given": {
            "setup": "User exists but password is incorrect",
            "code": "const mockUser = { username: 'testuser', password: 'hashedPassword' }; jest.spyOn(userRepository, 'login').mockResolvedValue(mockUser); jest.spyOn(require('../../utils/crypto'), 'safeCompare').mockReturnValue(false);"
          },
          "when": {
            "action": "Call authService.login with incorrect password",
            "code": "await authService.login(app, 'testuser', 'wrongpassword', 'req-1');"
          },
          "then": {
            "expectedReturn": "Throw ApplicationError",
            "expectedError": {
              "code": "AUTH_INVALID_CREDENTIALS",
              "statusCode": 401,
              "message": "Invalid username or passwords. You have X attempts left."
            },
            "code": "await expect(authService.login(app, 'testuser', 'wrongpassword', 'req-1')).rejects.toThrow(ApplicationError);\nconst error = await authService.login(app, 'testuser', 'wrongpassword', 'req-1').catch(e => e);\nexpect(error.code).toBe(ERROR_CODES.AUTH_INVALID_CREDENTIALS);\nexpect(error.statusCode).toBe(401);"
          },
          "testCode": "it('should throw AUTH_INVALID_CREDENTIALS when password is incorrect', async () => {\n  const app = await buildApp();\n  const mockUser = { username: 'testuser', password: 'hashedPassword' };\n  \n  jest.spyOn(userRepository, 'login').mockResolvedValue(mockUser);\n  jest.spyOn(require('../../utils/crypto'), 'safeCompare').mockReturnValue(false);\n  \n  await expect(authService.login(app, 'testuser', 'wrongpassword', 'req-1')).rejects.toThrow(ApplicationError);\n  \n  try {\n    await authService.login(app, 'testuser', 'wrongpassword', 'req-1');\n  } catch (error) {\n    expect(error.code).toBe(ERROR_CODES.AUTH_INVALID_CREDENTIALS);\n    expect(error.statusCode).toBe(401);\n    expect(error.details.attemptsLeft).toBeDefined();\n  }\n});",
          "implementationNotes": "Check that recordFailure is called and attemptsLeft is included in error details"
        },
        {
          "id": "auth-login-003",
          "name": "Error Case - Account Locked",
          "phase": "RED",
          "description": "Should throw ApplicationError with AUTH_ACCOUNT_LOCKED when account is locked after too many failed attempts",
          "given": {
            "setup": "Account is locked (isLocked returns true)",
            "code": "// Simulate locked account by setting loginAttempts map\nloginAttempts.set('testuser', { count: 5, lockedUntil: Date.now() + 3600000 });"
          },
          "when": {
            "action": "Call authService.login with locked account",
            "code": "await authService.login(app, 'testuser', 'password123', 'req-1');"
          },
          "then": {
            "expectedReturn": "Throw ApplicationError",
            "expectedError": {
              "code": "AUTH_ACCOUNT_LOCKED",
              "statusCode": 423,
              "message": "Account is locked due to too many failed attempts"
            },
            "code": "await expect(authService.login(app, 'testuser', 'password123', 'req-1')).rejects.toThrow(ApplicationError);\nconst error = await authService.login(app, 'testuser', 'password123', 'req-1').catch(e => e);\nexpect(error.code).toBe(ERROR_CODES.AUTH_ACCOUNT_LOCKED);\nexpect(error.statusCode).toBe(423);\nexpect(error.details.locked).toBe(true);"
          },
          "testCode": "it('should throw AUTH_ACCOUNT_LOCKED when account is locked', async () => {\n  const app = await buildApp();\n  \n  // Simulate locked account\n  loginAttempts.set('testuser', { count: 5, lockedUntil: Date.now() + 3600000 });\n  \n  await expect(authService.login(app, 'testuser', 'password123', 'req-1')).rejects.toThrow(ApplicationError);\n  \n  try {\n    await authService.login(app, 'testuser', 'password123', 'req-1');\n  } catch (error) {\n    expect(error.code).toBe(ERROR_CODES.AUTH_ACCOUNT_LOCKED);\n    expect(error.statusCode).toBe(423);\n    expect(error.details.locked).toBe(true);\n    expect(error.details.lockedUntil).toBeDefined();\n    expect(error.details.remainingMs).toBeDefined();\n  }\n});",
          "implementationNotes": "Test isLocked function and ensure proper lock info is returned"
        },
        {
          "id": "auth-login-004",
          "name": "Edge Case - Account Lock After Threshold",
          "phase": "RED",
          "description": "Should lock account when failed attempts reach MAX_LOGIN_ATTEMPTS threshold",
          "given": {
            "setup": "User has failed login attempts just below threshold",
            "code": "loginAttempts.set('testuser', { count: SECURITY_CONFIG.MAX_LOGIN_ATTEMPTS - 1 });\nconst mockUser = { username: 'testuser', password: 'hashedPassword' };\njest.spyOn(userRepository, 'login').mockResolvedValue(mockUser);\njest.spyOn(require('../../utils/crypto'), 'safeCompare').mockReturnValue(false);"
          },
          "when": {
            "action": "Call authService.login with incorrect password (reaching threshold)",
            "code": "await authService.login(app, 'testuser', 'wrongpassword', 'req-1');"
          },
          "then": {
            "expectedReturn": "Throw ApplicationError with account locked",
            "expectedSideEffects": [
              "Account should be locked (justLocked = true)",
              "lockedUntil should be set"
            ],
            "code": "try {\n  await authService.login(app, 'testuser', 'wrongpassword', 'req-1');\n} catch (error) {\n  expect(error.code).toBe(ERROR_CODES.AUTH_ACCOUNT_LOCKED);\n  expect(error.details.locked).toBe(true);\n  expect(error.details.lockedUntil).toBeDefined();\n}"
          },
          "testCode": "it('should lock account when threshold is reached', async () => {\n  const app = await buildApp();\n  loginAttempts.set('testuser', { count: SECURITY_CONFIG.MAX_LOGIN_ATTEMPTS - 1 });\n  \n  const mockUser = { username: 'testuser', password: 'hashedPassword' };\n  jest.spyOn(userRepository, 'login').mockResolvedValue(mockUser);\n  jest.spyOn(require('../../utils/crypto'), 'safeCompare').mockReturnValue(false);\n  \n  try {\n    await authService.login(app, 'testuser', 'wrongpassword', 'req-1');\n  } catch (error) {\n    expect(error.code).toBe(ERROR_CODES.AUTH_ACCOUNT_LOCKED);\n    expect(error.details.locked).toBe(true);\n    expect(error.details.lockedUntil).toBeDefined();\n  }\n});",
          "implementationNotes": "Test recordFailure function to ensure it sets lockedUntil when threshold is reached"
        }
      ],
      "todos": [
        {
          "id": "todo-login-001",
          "task": "Setup test file: src/tests/unit/auth.service.spec.ts",
          "status": "pending",
          "priority": "high",
          "description": "Create test file with describe block for authService.login"
        },
        {
          "id": "todo-login-002",
          "task": "Write test: Happy Path - Valid Credentials",
          "status": "pending",
          "priority": "high",
          "description": "Write test case for successful login with valid credentials"
        },
        {
          "id": "todo-login-003",
          "task": "Mock userRepository.login",
          "status": "pending",
          "priority": "high",
          "description": "Mock userRepository.login to return mock user data"
        },
        {
          "id": "todo-login-004",
          "task": "Mock safeCompare utility",
          "status": "pending",
          "priority": "high",
          "description": "Mock safeCompare from utils/crypto to return true for valid password"
        },
        {
          "id": "todo-login-005",
          "task": "Implement login function skeleton",
          "status": "pending",
          "priority": "high",
          "description": "Create async login function with parameters: app, username, password, requestId"
        },
        {
          "id": "todo-login-006",
          "task": "Call userRepository.login",
          "status": "pending",
          "priority": "high",
          "description": "Call userRepository.login(username, password) inside login function"
        },
        {
          "id": "todo-login-007",
          "task": "Validate password with safeCompare",
          "status": "pending",
          "priority": "high",
          "description": "Compare password using safeCompare utility"
        },
        {
          "id": "todo-login-008",
          "task": "Generate JWT token",
          "status": "pending",
          "priority": "high",
          "description": "Sign JWT token using app.jwt.sign with user payload"
        },
        {
          "id": "todo-login-009",
          "task": "Write test: Invalid Credentials",
          "status": "pending",
          "priority": "high",
          "description": "Write test case that expects ApplicationError with AUTH_INVALID_CREDENTIALS"
        },
        {
          "id": "todo-login-010",
          "task": "Implement error handling for invalid credentials",
          "status": "pending",
          "priority": "high",
          "description": "Throw ApplicationError when password validation fails"
        },
        {
          "id": "todo-login-011",
          "task": "Implement recordFailure function",
          "status": "pending",
          "priority": "medium",
          "description": "Create function to track failed login attempts"
        },
        {
          "id": "todo-login-012",
          "task": "Write test: Account Locked",
          "status": "pending",
          "priority": "high",
          "description": "Write test case for locked account scenario"
        },
        {
          "id": "todo-login-013",
          "task": "Implement isLocked function",
          "status": "pending",
          "priority": "medium",
          "description": "Create function to check if account is locked"
        },
        {
          "id": "todo-login-014",
          "task": "Add lockout logic after max attempts",
          "status": "pending",
          "priority": "medium",
          "description": "Lock account when failed attempts reach MAX_LOGIN_ATTEMPTS"
        },
        {
          "id": "todo-login-015",
          "task": "Add AuditLogger.logSuccess for successful login",
          "status": "pending",
          "priority": "medium",
          "description": "Log successful login using AuditLogger"
        },
        {
          "id": "todo-login-016",
          "task": "Add publishMonitoringLog for login events",
          "status": "pending",
          "priority": "medium",
          "description": "Publish monitoring log for all login events (success/failure)"
        },
        {
          "id": "todo-login-017",
          "task": "Refactor: Extract helper functions",
          "status": "pending",
          "priority": "low",
          "description": "Extract isLocked, recordFailure, resetAttempts, getLockInfo to separate functions"
        },
        {
          "id": "todo-login-018",
          "task": "Add JSDoc comments",
          "status": "pending",
          "priority": "low",
          "description": "Add documentation comments for function and parameters"
        }
      ],
      "bddScenarios": [
        {
          "id": "bdd-login-001",
          "name": "Feature: User Login",
          "description": "As a user, I want to login to the system so that I can access my account",
          "scenarios": [
            {
              "id": "bdd-login-001-001",
              "name": "Scenario: Successful Login with Valid Credentials",
              "given": [
                "User exists in the database with username 'testuser'",
                "User has password 'password123' stored in database",
                "User account is not locked",
                "User has not exceeded maximum login attempts"
              ],
              "when": [
                "User submits login request with username 'testuser'",
                "User submits password 'password123'",
                "System validates credentials"
              ],
              "then": [
                "System returns JWT token",
                "System returns user information (username, name, role)",
                "System logs successful login to audit trail",
                "System publishes monitoring log with LOGIN_SUCCESS status",
                "System resets any previous failed login attempts"
              ],
              "testCode": "it('should successfully login user with valid credentials', async () => {\n  // Given\n  const app = await buildApp();\n  const mockUser = { username: 'testuser', password: 'hashedPassword', name: 'Test User', role: 'ADMIN' };\n  jest.spyOn(userRepository, 'login').mockResolvedValue(mockUser);\n  jest.spyOn(require('../../utils/crypto'), 'safeCompare').mockReturnValue(true);\n  \n  // When\n  const result = await authService.login(app, 'testuser', 'password123', 'req-1');\n  \n  // Then\n  expect(result.token).toBeDefined();\n  expect(result.expiresIn).toBeDefined();\n  expect(result.user.username).toBe('testuser');\n  expect(result.user.name).toBe('Test User');\n  expect(AuditLogger.logSuccess).toHaveBeenCalled();\n});"
            },
            {
              "id": "bdd-login-001-002",
              "name": "Scenario: Login Fails with Invalid Password",
              "given": [
                "User exists in the database with username 'testuser'",
                "User has password 'password123' stored in database",
                "User account is not locked",
                "User has 2 failed login attempts remaining"
              ],
              "when": [
                "User submits login request with username 'testuser'",
                "User submits incorrect password 'wrongpassword'",
                "System validates credentials"
              ],
              "then": [
                "System throws ApplicationError with code AUTH_INVALID_CREDENTIALS",
                "System returns HTTP status code 401",
                "System includes remaining attempts count in error details",
                "System logs failed login attempt to audit trail",
                "System publishes monitoring log with LOGIN_FAILED status",
                "System increments failed login attempts counter"
              ],
              "testCode": "it('should fail login with invalid password', async () => {\n  // Given\n  const app = await buildApp();\n  const mockUser = { username: 'testuser', password: 'hashedPassword' };\n  jest.spyOn(userRepository, 'login').mockResolvedValue(mockUser);\n  jest.spyOn(require('../../utils/crypto'), 'safeCompare').mockReturnValue(false);\n  \n  // When & Then\n  await expect(authService.login(app, 'testuser', 'wrongpassword', 'req-1')).rejects.toThrow(ApplicationError);\n  \n  try {\n    await authService.login(app, 'testuser', 'wrongpassword', 'req-1');\n  } catch (error) {\n    expect(error.code).toBe(ERROR_CODES.AUTH_INVALID_CREDENTIALS);\n    expect(error.statusCode).toBe(401);\n    expect(error.details.attemptsLeft).toBeDefined();\n  }\n});"
            },
            {
              "id": "bdd-login-001-003",
              "name": "Scenario: Account Gets Locked After Maximum Failed Attempts",
              "given": [
                "User exists in the database",
                "User has 4 failed login attempts (1 attempt remaining before lockout)",
                "Maximum login attempts is set to 5"
              ],
              "when": [
                "User submits login request with incorrect password for the 5th time",
                "System validates and finds password is incorrect"
              ],
              "then": [
                "System locks the user account",
                "System sets lockout duration (LOCKOUT_DURATION_MS)",
                "System throws ApplicationError with code AUTH_ACCOUNT_LOCKED",
                "System returns HTTP status code 423 (Locked)",
                "System includes lockout information in error details (lockedUntil, remainingMs)",
                "System logs account lockout to audit trail",
                "System publishes monitoring log with account locked status"
              ],
              "testCode": "it('should lock account after maximum failed attempts', async () => {\n  // Given\n  const app = await buildApp();\n  loginAttempts.set('testuser', { count: 4 }); // 4 failed attempts\n  const mockUser = { username: 'testuser', password: 'hashedPassword' };\n  jest.spyOn(userRepository, 'login').mockResolvedValue(mockUser);\n  jest.spyOn(require('../../utils/crypto'), 'safeCompare').mockReturnValue(false);\n  \n  // When & Then\n  try {\n    await authService.login(app, 'testuser', 'wrongpassword', 'req-1');\n  } catch (error) {\n    expect(error.code).toBe(ERROR_CODES.AUTH_ACCOUNT_LOCKED);\n    expect(error.statusCode).toBe(423);\n    expect(error.details.locked).toBe(true);\n    expect(error.details.lockedUntil).toBeDefined();\n    expect(error.details.remainingMs).toBeDefined();\n  }\n});"
            },
            {
              "id": "bdd-login-001-004",
              "name": "Scenario: Login Attempt on Already Locked Account",
              "given": [
                "User account is already locked",
                "Lockout period has not expired",
                "User attempts to login"
              ],
              "when": [
                "User submits login request with any credentials",
                "System checks account lock status"
              ],
              "then": [
                "System immediately rejects login attempt",
                "System throws ApplicationError with code AUTH_ACCOUNT_LOCKED",
                "System returns HTTP status code 423",
                "System includes remaining lockout time in error details",
                "System does not attempt to validate credentials",
                "System logs locked account access attempt"
              ],
              "testCode": "it('should reject login when account is already locked', async () => {\n  // Given\n  const app = await buildApp();\n  const lockUntil = Date.now() + 3600000; // 1 hour from now\n  loginAttempts.set('testuser', { count: 5, lockedUntil: lockUntil });\n  \n  // When & Then\n  await expect(authService.login(app, 'testuser', 'password123', 'req-1')).rejects.toThrow(ApplicationError);\n  \n  try {\n    await authService.login(app, 'testuser', 'password123', 'req-1');\n  } catch (error) {\n    expect(error.code).toBe(ERROR_CODES.AUTH_ACCOUNT_LOCKED);\n    expect(error.statusCode).toBe(423);\n    expect(error.details.locked).toBe(true);\n    expect(error.details.remainingMs).toBeGreaterThan(0);\n  }\n});"
            },
            {
              "id": "bdd-login-001-005",
              "name": "Scenario: Account Lock Expires and Resets",
              "given": [
                "User account was previously locked",
                "Lockout period has expired",
                "User attempts to login"
              ],
              "when": [
                "User submits login request",
                "System checks lock status and finds it has expired"
              ],
              "then": [
                "System resets the lockout counter",
                "System allows login attempt to proceed",
                "System validates credentials normally",
                "If credentials are valid, login succeeds",
                "If credentials are invalid, new lockout cycle begins"
              ],
              "testCode": "it('should reset lockout after expiration', async () => {\n  // Given\n  const app = await buildApp();\n  const expiredLock = Date.now() - 1000; // Lock expired 1 second ago\n  loginAttempts.set('testuser', { count: 5, lockedUntil: expiredLock });\n  const mockUser = { username: 'testuser', password: 'hashedPassword', name: 'Test User', role: 'ADMIN' };\n  jest.spyOn(userRepository, 'login').mockResolvedValue(mockUser);\n  jest.spyOn(require('../../utils/crypto'), 'safeCompare').mockReturnValue(true);\n  \n  // When\n  const result = await authService.login(app, 'testuser', 'password123', 'req-1');\n  \n  // Then\n  expect(result.token).toBeDefined();\n  // Lockout should be reset\n  expect(loginAttempts.get('testuser')).toBeUndefined();\n});"
            }
          ]
        }
      ],
      "dod": {
        "criteria": [
          {
            "id": "dod-1",
            "description": "All test scenarios implemented and passing",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-2",
            "description": "Code coverage meets minimum threshold (70%)",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-3",
            "description": "Error handling implemented for all error cases",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-4",
            "description": "Code reviewed and approved",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-5",
            "description": "Documentation updated",
            "status": "PENDING",
            "evidence": ""
          }
        ],
        "acceptanceCriteria": [
          {
            "id": "ac-1",
            "description": "Should return token and user data when credentials are valid",
            "testScenarioId": "auth-login-001",
            "status": "PENDING"
          },
          {
            "id": "ac-2",
            "description": "Should throw ApplicationError with AUTH_INVALID_CREDENTIALS when password is incorrect",
            "testScenarioId": "auth-login-002",
            "status": "PENDING"
          },
          {
            "id": "ac-3",
            "description": "Should throw ApplicationError with AUTH_ACCOUNT_LOCKED when account is locked after too many failed attempts",
            "testScenarioId": "auth-login-003",
            "status": "PENDING"
          },
          {
            "id": "ac-4",
            "description": "Should lock account when failed attempts reach MAX_LOGIN_ATTEMPTS threshold",
            "testScenarioId": "auth-login-004",
            "status": "PENDING"
          }
        ]
      }
    },
    {
      "name": "getMenu",
      "signature": "async getMenu(username: string): Promise<ServiceResponse<MenuNode[]>>",
      "description": "Get menu items for a user based on their authorization",
      "category": "service",
      "parameters": [
        {
          "name": "username",
          "type": "string",
          "description": "Username to get menu for"
        }
      ],
      "returnType": "Promise<ServiceResponse<MenuNode[]>>",
      "dependencies": [
        "userRepository",
        "ServiceResponse"
      ],
      "testScenarios": [
        {
          "id": "auth-getMenu-001",
          "name": "Happy Path - User Has Menu",
          "phase": "RED",
          "description": "Should return menu items when user has valid authorization",
          "given": {
            "setup": "User has menu items in database",
            "code": "const mockMenus = [{ MENU_ID: '1', MENU_TEXT: 'Dashboard', MENU_PARENT: null }];\njest.spyOn(userRepository, 'getMenu').mockResolvedValue(mockMenus);"
          },
          "when": {
            "action": "Call authService.getMenu",
            "code": "const result = await authService.getMenu('testuser');"
          },
          "then": {
            "expectedReturn": "ServiceResponse with success: true and menu data",
            "code": "expect(result.success).toBe(true);\nexpect(result.data).toBeDefined();\nexpect(Array.isArray(result.data)).toBe(true);"
          },
          "testCode": "it('should return menu items for user', async () => {\n  const mockMenus = [{ MENU_ID: '1', MENU_TEXT: 'Dashboard', MENU_PARENT: null }];\n  jest.spyOn(userRepository, 'getMenu').mockResolvedValue(mockMenus);\n  \n  const result = await authService.getMenu('testuser');\n  \n  expect(result.success).toBe(true);\n  expect(result.data).toBeDefined();\n  expect(Array.isArray(result.data)).toBe(true);\n});",
          "implementationNotes": "Ensure userRepository.getMenu is mocked properly"
        }
      ],
      "implementationGuide": {
        "steps": [
          {
            "title": "Write Test Case",
            "description": "Write test for getMenu function. Run test - it should fail."
          },
          {
            "title": "Implement Function",
            "description": "Implement getMenu to call userRepository.getMenu and wrap in ServiceResponse. Run test - it should pass."
          }
        ]
      },
      "todos": [
        {
          "id": "todo-getMenu-001",
          "task": "Setup test file: src/tests/unit/auth.service.spec.ts (getMenu section)",
          "status": "pending",
          "priority": "high",
          "description": "Add describe block for authService.getMenu tests"
        },
        {
          "id": "todo-getMenu-002",
          "task": "Write test: User Has Menu Items",
          "status": "pending",
          "priority": "high",
          "description": "Write test case for successful menu retrieval"
        },
        {
          "id": "todo-getMenu-003",
          "task": "Mock userRepository.getMenu",
          "status": "pending",
          "priority": "high",
          "description": "Mock userRepository.getMenu to return menu items array"
        },
        {
          "id": "todo-getMenu-004",
          "task": "Implement getMenu function",
          "status": "pending",
          "priority": "high",
          "description": "Call userRepository.getMenu and wrap result in ServiceResponse"
        },
        {
          "id": "todo-getMenu-005",
          "task": "Write test: Empty Menu for User Without Authorization",
          "status": "pending",
          "priority": "medium",
          "description": "Write test case when user has no menu items"
        },
        {
          "id": "todo-getMenu-006",
          "task": "Handle empty menu case",
          "status": "pending",
          "priority": "medium",
          "description": "Return empty array in ServiceResponse when no menu items"
        },
        {
          "id": "todo-getMenu-007",
          "task": "Write test: Menu Tree Structure",
          "status": "pending",
          "priority": "medium",
          "description": "Test that menu items are properly structured as tree"
        },
        {
          "id": "todo-getMenu-008",
          "task": "Verify menu tree structure",
          "status": "pending",
          "priority": "low",
          "description": "Ensure menu items with MENU_PARENT are nested correctly"
        }
      ],
      "bddScenarios": [
        {
          "id": "bdd-getMenu-001",
          "name": "Feature: Get User Menu",
          "description": "As a user, I want to retrieve my authorized menu items so that I can navigate the application",
          "scenarios": [
            {
              "id": "bdd-getMenu-001-001",
              "name": "Scenario: User Retrieves Menu Items Successfully",
              "given": [
                "User 'testuser' exists in the system",
                "User has role 'ADMIN' assigned",
                "Menu items exist in database for role 'ADMIN'",
                "Menu authorization is configured correctly"
              ],
              "when": [
                "User calls getMenu with username 'testuser'",
                "System queries menu items for user's authorization"
              ],
              "then": [
                "System returns ServiceResponse with success: true",
                "System returns array of menu items",
                "Menu items include MENU_ID, MENU_TEXT, MENU_PARENT properties",
                "Menu items are filtered based on user's role/function/feature authorization"
              ],
              "testCode": "it('should return menu items for user with authorization', async () => {\n  // Given\n  const mockMenus = [\n    { MENU_ID: '1', MENU_TEXT: 'Dashboard', MENU_PARENT: null },\n    { MENU_ID: '2', MENU_TEXT: 'Settings', MENU_PARENT: null }\n  ];\n  jest.spyOn(userRepository, 'getMenu').mockResolvedValue(mockMenus);\n  \n  // When\n  const result = await authService.getMenu('testuser');\n  \n  // Then\n  expect(result.success).toBe(true);\n  expect(result.data).toBeDefined();\n  expect(Array.isArray(result.data)).toBe(true);\n  expect(result.data.length).toBeGreaterThan(0);\n});"
            },
            {
              "id": "bdd-getMenu-001-002",
              "name": "Scenario: User Without Authorization Gets Empty Menu",
              "given": [
                "User 'testuser' exists in the system",
                "User has no role, function, or feature authorization assigned",
                "No menu items are authorized for this user"
              ],
              "when": [
                "User calls getMenu with username 'testuser'",
                "System queries menu items for user's authorization"
              ],
              "then": [
                "System returns ServiceResponse with success: true",
                "System returns empty array",
                "No menu items are returned"
              ],
              "testCode": "it('should return empty menu for user without authorization', async () => {\n  // Given\n  jest.spyOn(userRepository, 'getMenu').mockResolvedValue([]);\n  \n  // When\n  const result = await authService.getMenu('testuser');\n  \n  // Then\n  expect(result.success).toBe(true);\n  expect(result.data).toBeDefined();\n  expect(Array.isArray(result.data)).toBe(true);\n  expect(result.data.length).toBe(0);\n});"
            }
          ]
        }
      ]
    },
    {
      "name": "getProfile",
      "signature": "async getProfile(username: string): Promise<ServiceResponse<UserProfile>>",
      "description": "Get user profile information",
      "category": "service",
      "parameters": [
        {
          "name": "username",
          "type": "string",
          "description": "Username to get profile for"
        }
      ],
      "returnType": "Promise<ServiceResponse<UserProfile>>",
      "dependencies": [
        "userRepository",
        "ServiceResponse"
      ],
      "testScenarios": [
        {
          "id": "auth-getProfile-001",
          "name": "Happy Path - User Profile Found",
          "phase": "RED",
          "description": "Should return user profile when user exists",
          "given": {
            "setup": "User exists in database",
            "code": "const mockProfile = { user: { username: 'testuser', name: 'Test User' }, roles: ['ADMIN'] };\njest.spyOn(userRepository, 'getProfile').mockResolvedValue(mockProfile);"
          },
          "when": {
            "action": "Call authService.getProfile",
            "code": "const result = await authService.getProfile('testuser');"
          },
          "then": {
            "expectedReturn": "ServiceResponse with user profile data",
            "code": "expect(result.success).toBe(true);\nexpect(result.data.user.username).toBe('testuser');"
          },
          "testCode": "it('should return user profile', async () => {\n  const mockProfile = { user: { username: 'testuser', name: 'Test User' }, roles: ['ADMIN'] };\n  jest.spyOn(userRepository, 'getProfile').mockResolvedValue(mockProfile);\n  \n  const result = await authService.getProfile('testuser');\n  \n  expect(result.success).toBe(true);\n  expect(result.data.user.username).toBe('testuser');\n});",
          "implementationNotes": "Mock userRepository.getProfile to return profile data"
        }
      ],
      "implementationGuide": {
        "steps": [
          {
            "title": "Write Test Case",
            "description": "Write test for getProfile. Run test - it should fail."
          },
          {
            "title": "Implement Function",
            "description": "Implement getProfile to call repository and return ServiceResponse. Run test - it should pass."
          }
        ]
      },
      "todos": [
        {
          "id": "todo-getProfile-001",
          "task": "Setup test file: src/tests/unit/auth.service.spec.ts (getProfile section)",
          "status": "pending",
          "priority": "high",
          "description": "Add describe block for authService.getProfile tests"
        },
        {
          "id": "todo-getProfile-002",
          "task": "Write test: User Profile Found",
          "status": "pending",
          "priority": "high",
          "description": "Write test case for successful profile retrieval"
        },
        {
          "id": "todo-getProfile-003",
          "task": "Mock userRepository.getProfile",
          "status": "pending",
          "priority": "high",
          "description": "Mock userRepository.getProfile to return user profile data"
        },
        {
          "id": "todo-getProfile-004",
          "task": "Implement getProfile function",
          "status": "pending",
          "priority": "high",
          "description": "Call userRepository.getProfile and wrap result in ServiceResponse"
        },
        {
          "id": "todo-getProfile-005",
          "task": "Write test: User Not Found",
          "status": "pending",
          "priority": "medium",
          "description": "Write test case when user does not exist"
        },
        {
          "id": "todo-getProfile-006",
          "task": "Handle user not found error",
          "status": "pending",
          "priority": "medium",
          "description": "Return error in ServiceResponse when user is not found"
        },
        {
          "id": "todo-getProfile-007",
          "task": "Verify profile includes user, roles, features, functions",
          "status": "pending",
          "priority": "medium",
          "description": "Ensure profile response includes all required fields"
        }
      ],
      "bddScenarios": [
        {
          "id": "bdd-getProfile-001",
          "name": "Feature: Get User Profile",
          "description": "As a user, I want to retrieve my profile information so that I can view my account details",
          "scenarios": [
            {
              "id": "bdd-getProfile-001-001",
              "name": "Scenario: User Retrieves Profile Successfully",
              "given": [
                "User 'testuser' exists in the database",
                "User has profile information (name, email, company, etc.)",
                "User has roles, features, and functions assigned"
              ],
              "when": [
                "User calls getProfile with username 'testuser'",
                "System queries user profile from database"
              ],
              "then": [
                "System returns ServiceResponse with success: true",
                "System returns user profile data",
                "Profile includes user basic information (username, name, company)",
                "Profile includes user roles array",
                "Profile includes user features array",
                "Profile includes user functions array"
              ],
              "testCode": "it('should return user profile with all information', async () => {\n  // Given\n  const mockProfile = {\n    user: { username: 'testuser', name: 'Test User', COMPANY: 'COMP001' },\n    roles: [{ ID: 'ADMIN', NAME: 'Administrator' }],\n    features: [{ ID: 'FEAT001' }],\n    functions: [{ ID: 'FUNC001' }]\n  };\n  jest.spyOn(userRepository, 'getProfile').mockResolvedValue(mockProfile);\n  \n  // When\n  const result = await authService.getProfile('testuser');\n  \n  // Then\n  expect(result.success).toBe(true);\n  expect(result.data.user.username).toBe('testuser');\n  expect(result.data.roles).toBeDefined();\n  expect(result.data.features).toBeDefined();\n  expect(result.data.functions).toBeDefined();\n});"
            },
            {
              "id": "bdd-getProfile-001-002",
              "name": "Scenario: User Profile Not Found",
              "given": [
                "User 'testuser' does not exist in the database",
                "System attempts to retrieve profile"
              ],
              "when": [
                "User calls getProfile with username 'testuser'",
                "System queries user profile from database"
              ],
              "then": [
                "System returns ServiceResponse with success: false",
                "System returns error message",
                "System includes error code indicating user not found"
              ],
              "testCode": "it('should return error when user profile not found', async () => {\n  // Given\n  jest.spyOn(userRepository, 'getProfile').mockRejectedValue(new Error('User not found'));\n  \n  // When & Then\n  await expect(authService.getProfile('testuser')).rejects.toThrow();\n});"
            }
          ]
        }
      ]
    },
    {
      "name": "logout",
      "description": "Logout user and log audit trail",
      "signature": "POST /logout",
      "method": "POST",
      "endpoint": "/logout",
      "testScenarios": [
        {
          "id": "auth-logout-001",
          "name": "Happy Path - Logout Success",
          "phase": "RED",
          "description": "Should return true and log audit when logout succeeds",
          "given": {
            "setup": "Valid JWT token",
            "code": "const app = await buildApp();\nconst token = app.jwt.sign({ sub: 'testuser', role: 'ADMIN' });"
          },
          "when": {
            "action": "Call authService.logout",
            "code": "const result = await authService.logout(app, token, 'req-1');"
          },
          "then": {
            "expectedReturn": "true",
            "expectedSideEffects": [
              "AuditLogger.logSuccess called",
              "publishMonitoringLog called"
            ],
            "code": "expect(result).toBe(true);\nexpect(AuditLogger.logSuccess).toHaveBeenCalled();"
          },
          "testCode": "it('should logout user successfully', async () => {\n  const app = await buildApp();\n  const token = app.jwt.sign({ sub: 'testuser', role: 'ADMIN' });\n  \n  jest.spyOn(AuditLogger, 'logSuccess');\n  \n  const result = await authService.logout(app, token, 'req-1');\n  \n  expect(result).toBe(true);\n  expect(AuditLogger.logSuccess).toHaveBeenCalledWith(\n    AuditAction.LOGOUT_SUCCESS,\n    expect.objectContaining({ userId: 'testuser' })\n  );\n});",
          "implementationNotes": "Mock AuditLogger and verify it's called with correct parameters"
        }
      ],
      "todos": [
        {
          "id": "todo-logout-001",
          "task": "Setup test file: src/tests/unit/auth.service.spec.ts (logout section)",
          "status": "pending",
          "priority": "high",
          "description": "Add describe block for authService.logout tests"
        },
        {
          "id": "todo-logout-002",
          "task": "Write test: Logout Success",
          "status": "pending",
          "priority": "high",
          "description": "Write test case for successful logout"
        },
        {
          "id": "todo-logout-003",
          "task": "Mock app.jwt.decode",
          "status": "pending",
          "priority": "high",
          "description": "Mock Fastify JWT decode to return user payload"
        },
        {
          "id": "todo-logout-004",
          "task": "Implement logout function",
          "status": "pending",
          "priority": "high",
          "description": "Decode JWT token, extract user info, log audit, and return true"
        },
        {
          "id": "todo-logout-005",
          "task": "Add AuditLogger.logSuccess call",
          "status": "pending",
          "priority": "high",
          "description": "Log successful logout using AuditLogger with LOGOUT_SUCCESS action"
        },
        {
          "id": "todo-logout-006",
          "task": "Add publishMonitoringLog call",
          "status": "pending",
          "priority": "medium",
          "description": "Publish monitoring log for logout event"
        },
        {
          "id": "todo-logout-007",
          "task": "Write test: Invalid Token",
          "status": "pending",
          "priority": "medium",
          "description": "Write test case when token is invalid or cannot be decoded"
        },
        {
          "id": "todo-logout-008",
          "task": "Handle invalid token gracefully",
          "status": "pending",
          "priority": "medium",
          "description": "Handle case when token cannot be decoded (return false or log error)"
        }
      ],
      "bddScenarios": [
        {
          "id": "bdd-logout-001",
          "name": "Feature: User Logout",
          "description": "As a user, I want to logout from the system so that my session is properly terminated",
          "scenarios": [
            {
              "id": "bdd-logout-001-001",
              "name": "Scenario: User Logs Out Successfully",
              "given": [
                "User is logged in with valid JWT token",
                "Token contains user information (sub, role, name)",
                "System has audit logging enabled"
              ],
              "when": [
                "User calls logout with valid JWT token",
                "System decodes the token",
                "System processes logout request"
              ],
              "then": [
                "System returns true indicating successful logout",
                "System logs logout event to audit trail",
                "System logs user ID, request ID, and timestamp",
                "System publishes monitoring log with LOGOUT_SUCCESS status",
                "Logout action is recorded with AuditAction.LOGOUT_SUCCESS"
              ],
              "testCode": "it('should logout user successfully and log audit', async () => {\n  // Given\n  const app = await buildApp();\n  const token = app.jwt.sign({ sub: 'testuser', role: 'ADMIN', name: 'Test User' });\n  jest.spyOn(AuditLogger, 'logSuccess');\n  \n  // When\n  const result = await authService.logout(app, token, 'req-1');\n  \n  // Then\n  expect(result).toBe(true);\n  expect(AuditLogger.logSuccess).toHaveBeenCalledWith(\n    AuditAction.LOGOUT_SUCCESS,\n    expect.objectContaining({\n      userId: 'testuser',\n      requestId: 'req-1'\n    })\n  );\n});"
            },
            {
              "id": "bdd-logout-001-002",
              "name": "Scenario: Logout with Invalid Token",
              "given": [
                "User provides invalid or expired JWT token",
                "Token cannot be decoded by the system"
              ],
              "when": [
                "User calls logout with invalid token",
                "System attempts to decode the token"
              ],
              "then": [
                "System handles error gracefully",
                "System returns false or throws appropriate error",
                "System logs error to audit trail if applicable",
                "Invalid token error is handled without crashing"
              ],
              "testCode": "it('should handle invalid token gracefully', async () => {\n  // Given\n  const app = await buildApp();\n  const invalidToken = 'invalid.jwt.token';\n  \n  // When & Then\n  try {\n    const result = await authService.logout(app, invalidToken, 'req-1');\n    // Should either return false or handle gracefully\n    expect(result).toBeDefined();\n  } catch (error) {\n    // Or should throw appropriate error\n    expect(error).toBeDefined();\n  }\n});"
            }
          ]
        }
      ],
      "dod": {
        "criteria": [
          {
            "id": "dod-1",
            "description": "All test scenarios implemented and passing",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-2",
            "description": "Code coverage meets minimum threshold (70%)",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-3",
            "description": "Error handling implemented for all error cases",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-4",
            "description": "Code reviewed and approved",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-5",
            "description": "Documentation updated",
            "status": "PENDING",
            "evidence": ""
          }
        ],
        "acceptanceCriteria": [
          {
            "id": "ac-1",
            "description": "Should return true and log audit when logout succeeds",
            "testScenarioId": "auth-logout-001",
            "status": "PENDING"
          }
        ]
      }
    },
    {
      "name": "menu",
      "description": "Handles GET request to /menu",
      "signature": "GET /menu",
      "method": "GET",
      "endpoint": "/menu",
      "testScenarios": [
        {
          "phase": "RED",
          "description": "Test menu should fail initially",
          "testCode": "it('should menu', async () => {\n  // TODO: Implement test\n});",
          "expectedResult": "Test should fail"
        },
        {
          "phase": "GREEN",
          "description": "Test menu should pass after implementation",
          "testCode": "it('should menu', async () => {\n  // TODO: Implement test\n});",
          "expectedResult": "Test should pass"
        },
        {
          "phase": "REFACTOR",
          "description": "Refactor menu implementation",
          "testCode": "// TODO: Refactor code\n// All tests should still pass",
          "expectedResult": "Code refactored, tests still pass"
        }
      ],
      "todos": [
        {
          "id": "1",
          "task": "Implement menu function",
          "status": "pending",
          "priority": "high",
          "description": "Create implementation for menu"
        }
      ],
      "bddScenarios": [
        {
          "feature": "menu Feature",
          "description": "As a developer, I want to menu so that I can handle the request",
          "scenarios": [
            {
              "name": "menu Success Scenario",
              "given": "Given I have valid request",
              "when": "When I call menu",
              "then": "Then I should receive successful response",
              "testCode": "// TODO: Implement BDD test"
            }
          ]
        }
      ],
      "dod": {
        "criteria": [
          {
            "id": "dod-1",
            "description": "All test scenarios implemented and passing",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-2",
            "description": "Code coverage meets minimum threshold (70%)",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-3",
            "description": "Error handling implemented for all error cases",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-4",
            "description": "Code reviewed and approved",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-5",
            "description": "Documentation updated",
            "status": "PENDING",
            "evidence": ""
          }
        ],
        "acceptanceCriteria": [
          {
            "id": "ac-1",
            "description": "Test menu should fail initially",
            "testScenarioId": "menu-scenario-1",
            "status": "PENDING"
          },
          {
            "id": "ac-2",
            "description": "Test menu should pass after implementation",
            "testScenarioId": "menu-scenario-2",
            "status": "PENDING"
          },
          {
            "id": "ac-3",
            "description": "Refactor menu implementation",
            "testScenarioId": "menu-scenario-3",
            "status": "PENDING"
          }
        ]
      }
    },
    {
      "name": "profile",
      "description": "Handles GET request to /profile",
      "signature": "GET /profile",
      "method": "GET",
      "endpoint": "/profile",
      "testScenarios": [
        {
          "phase": "RED",
          "description": "Test profile should fail initially",
          "testCode": "it('should profile', async () => {\n  // TODO: Implement test\n});",
          "expectedResult": "Test should fail"
        },
        {
          "phase": "GREEN",
          "description": "Test profile should pass after implementation",
          "testCode": "it('should profile', async () => {\n  // TODO: Implement test\n});",
          "expectedResult": "Test should pass"
        },
        {
          "phase": "REFACTOR",
          "description": "Refactor profile implementation",
          "testCode": "// TODO: Refactor code\n// All tests should still pass",
          "expectedResult": "Code refactored, tests still pass"
        }
      ],
      "todos": [
        {
          "id": "1",
          "task": "Implement profile function",
          "status": "pending",
          "priority": "high",
          "description": "Create implementation for profile"
        }
      ],
      "bddScenarios": [
        {
          "feature": "profile Feature",
          "description": "As a developer, I want to profile so that I can handle the request",
          "scenarios": [
            {
              "name": "profile Success Scenario",
              "given": "Given I have valid request",
              "when": "When I call profile",
              "then": "Then I should receive successful response",
              "testCode": "// TODO: Implement BDD test"
            }
          ]
        }
      ],
      "dod": {
        "criteria": [
          {
            "id": "dod-1",
            "description": "All test scenarios implemented and passing",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-2",
            "description": "Code coverage meets minimum threshold (70%)",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-3",
            "description": "Error handling implemented for all error cases",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-4",
            "description": "Code reviewed and approved",
            "status": "PENDING",
            "evidence": ""
          },
          {
            "id": "dod-5",
            "description": "Documentation updated",
            "status": "PENDING",
            "evidence": ""
          }
        ],
        "acceptanceCriteria": [
          {
            "id": "ac-1",
            "description": "Test profile should fail initially",
            "testScenarioId": "profile-scenario-1",
            "status": "PENDING"
          },
          {
            "id": "ac-2",
            "description": "Test profile should pass after implementation",
            "testScenarioId": "profile-scenario-2",
            "status": "PENDING"
          },
          {
            "id": "ac-3",
            "description": "Refactor profile implementation",
            "testScenarioId": "profile-scenario-3",
            "status": "PENDING"
          }
        ]
      }
    }
  ]
}